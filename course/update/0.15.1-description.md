---
outline: deep
comments: false
showVersion: false
---

# `0.15.1`

2025/8/30，`0.15.1` 发布，自上一个版本来历时 5 个月，共有 162 位贡献者参与，进行了 647 次提交！

> 本次更新，Zig 团队直接从 `0.14.1` 跨越到了 `0.15.1`。

Zig 目前默认使用 x86 后端，调试编译速度提高了 **5** 倍；aarch64 后端正在开发中。

目前 Zig 已经进入了语言稳定的最后关头，本次更新带来了部分 break change，同时一直等待的 async 特性也有苗头了。

## 系统最低版本要求

| 操作系统（Operating System） | 最低版本要求（Minimum Version） |
| :--------------------------- | :------------------------------: |
| Dragonfly BSD                |               6.0                |
| FreeBSD                      |               14.0               |
| Linux                        |               5.10               |
| NetBSD                       |               10.1               |
| OpenBSD                      |               7.6                |
| macOS                        |               13.0               |
| Solaris                      |                11                |
| Windows                      |                10                |

## 语言变动

小改动：

packed union 字段现在不允许再单独指定 align 属性，这与 packed struct 的现有行为保持一致。此前即使为字段强制指定了对齐方式，也不会实际影响字段的对齐，这次迁移只需删去该部分即可。[#22997](https://github.com/ziglang/zig/pull/22997)

### 移除 `usingnamespace`

该关键字增加了 `declaration` 的“预期”定义位置与“实际”定义位置之间的距离。在没有它的情况下，查找某个 `declaration` 的定义非常简单：只需找到你要查找的命名空间的定义，再在该类型 `declaration` 内部找到具体标识符即可。然而，有了 usingnamespace，程序员常常会被迫在不同类型和文件之间反复查找，寻觅声明的真实 `declaration` 位置。

这不仅影响了人类的可读性，对于工具链来说也带来了问题；例如，`Autodoc` 在遇到复杂的 `usingnamespace` 用法时无法准确分析（可以试着在 `0.14.1` 文档中查找 `std.c` 下的 `dl_iterate_phdr`）。

移除该特性后，所有标识符的来源都可以被轻松追溯到其实际导入的位置。

此外，`usingnamespace` 还会导致糟糕的命名空间划分。当声明被存放在单独的文件中时，通常意味着这些声明彼此之间有某些共同点，而与其他文件的内容无关。因此，将这些声明通过单独的命名空间进行暴露，而不是混入一个更通用的父级命名空间，其实是更合理的选择。简而言之：**好的命名空间结构是非常有价值的**。

最后，移除该特性让增量编译的实现变得根本上更加简单。

#### 示例：条件包含

`usingnamespace` 以前常用于有条件地包含声明，比如如下写法：

```zig
pub usingnamespace if (have_foo) struct {
    pub const foo = 123;
} else struct {};
```

现在的替代办法其实非常简单：通常可以直接无条件地声明即可。Zig 拥有惰性编译特性，未被引用的声明不会被分析，因此这样不会有问题！

```zig
pub const foo = 123;
```

但有时这种做法并不安全。例如，`foo` 虽然总能分析通过，但只有在 `have_foo` 为 true 时才有实际意义，在其他情况下引用则属于 bug。这种场景下，可以让未支持时声明直接在编译时报错：

```zig
pub const foo = if (have_foo)
    123
else
    @compileError("foo not supported on this target");
```

不过，这样做会破坏用 `@hasDecl` 进行特性检测的能力。如果确实需要特性检测，更推荐的写法是：将声明条件初始化为某种可检测的“哨兵值”（sentinel value），这样既不容易写错，也方便维护。常用的方案是使用 void 类型的 `{}`：

```zig feature-detection.zig
const something = struct {
    // 本例中，foo 被支持，bar 不被支持。
    const have_foo = true;
    const have_bar = false;
    pub const foo = if (have_foo) 123 else {};
    pub const bar = if (have_bar) undefined else {};
};

test "use foo if supported" {
    if (@TypeOf(something.foo) == void) return error.SkipZigTest; // 不支持
    try expect(something.foo == 123);
}

test "use bar if supported" {
    if (@TypeOf(something.bar) == void) return error.SkipZigTest; // 不支持
    try expect(something.bar == 456);
}

const expect = @import("std").testing.expect;
```

#### 用例示例：多实现切换（Implementation Switching）

`usingnamespace` 的另一个常见用途是根据不同条件（如平台目标）在编译期选择不同的实现体，如：

```zig
pub usingnamespace switch (target) {
    .windows => struct {
        pub const target_name = "windows";
        pub fn init() T {
            // ...
        }
    },
    else => struct {
        pub const target_name = "something good";
        pub fn init() T {
            // ...
        }
    },
};
```

替代方式其实更简单，推荐直接将定义本身写成条件表达式：

```zig
pub const target_name = switch (target) {
    .windows => "windows",
    else => "something good",
};
pub const init = switch (target) {
    .windows => initWindows,
    else => initOther,
};
fn initWindows() T {
    // ...
}
fn initOther() T {
    // ...
}
```

#### 用例示例：Mixins 混入

使用 `usingnamespace` 的另一个常见场景，是实现“混入”特性（mixins）：

```zig
/// 提供操作 `count` 字段方法的混入体。
pub fn CounterMixin(comptime T: type) type {
    return struct {
        pub fn incrementCounter(x: *T) void {
            x.count += 1;
        }
        pub fn resetCounter(x: *T) void {
            x.count = 0;
        }
    };
}

pub const Foo = struct {
    count: u32 = 0,
    pub usingnamespace CounterMixin(Foo);
};
```

替代写法基于前述的命名空间思想：其实**恰当的命名空间划分是好事**。Mixins 也可以用命名空间来组织。比如把 `incrementCounter` 和 `resetCounter` 名称中的“counter”前缀直接变成一个嵌套字段，这样 `foo.counter.increment()` 替代 `foo.incrementCounter()`，语义更直观。

实现方式可利用零位字段（zero-bit field）和 `@fieldParentPtr`：

```zig
/// 提供操作 `count` 字段方法的混入体。
pub fn CounterMixin(comptime T: type) type {
    return struct {
        pub fn increment(m: *@This()) void {
            const x: *T = @alignCast(@fieldParentPtr("counter", m));
            x.count += 1;
        }
        pub fn reset(m: *@This()) void {
            const x: *T = @alignCast(@fieldParentPtr("counter", m));
            x.count = 0;
        }
    };
}

pub const Foo = struct {
    count: u32 = 0,
    counter: CounterMixin(Foo) = .{},
};
```

这样写后，调用就是 `foo.counter.increment()`，不再是 `foo.incrementCounter()`。通过零位字段成功将 mixin“命名空间化”。

实际上，这比以前更灵活，也能让混入体包含如字段等更多内容。比如本例中甚至可以将 `count` 字段本身都移到 `CounterMixin` 内部（虽然这种场景下其实不算 mixin，因为只剩状态本身）。

更重要的是，如果某些复杂混入需要额外状态，这种办法也能避免每个站点都重复字段声明，维护起来更方便。

### 移除 async 和 await 关键字

`async` 和 `await` 关键字已被移除，`@frameSize` 也已删除。

虽然 `suspend`、`resume` 及协程底层机制是否保留还需依据“无栈协程原语提案”进一步决定，但可以确认，Zig 语言层面将不再有 `async/await` 这样的关键字。

未来异步相关能力将仅以标准库的一部分（比如 Io 接口）存在。

### 非穷尽枚举的 switch 改进

现在，针对非穷尽（non-exhaustive）枚举使用 `switch` 时，可以将显式枚举标签与 `_` 分支（代表所有未命名值）组合：

```zig
switch (enum_val) {
    .special_case_1 => foo(),
    .special_case_2 => bar(),
    _, .special_case_3 => baz(),
}
```

此外，`switch` 语句现在也允许同时使用 `else` 和 `_`：

```zig
const Enum = enum(u32) {
    A = 1,
    B = 2,
    C = 44,
    _
};

fn someOtherFunction(value: Enum) void {
    // 这样写会编译报错：“error: else and '_' prong in switch expression”
    switch (value) {
        .A   => {},
        .C   => {},
        else => {}, // 此处处理已命名但未列出的标签（这里就是 .B）
        _    => {}, // 此处处理未命名标签
    }
}
```

### 布尔向量支持更多运算符

布尔向量现在支持按位非、按位与、按位或、按位异或，以及布尔非等运算。

### 内联汇编：类型化的 clobber 描述符

此前，clobber 描述符仅支持字符串类型。现在它们变为类型化的，实际用起来会更直观。

```zig
pub fn syscall1(number: usize, arg1: usize) usize {
    return asm volatile ("syscall"
        : [ret] "={rax}" (-> usize),
        : [number] "{rax}" (number),
          [arg1] "{rdi}" (arg1),
        : "rcx", "r11"
    );
}
```

⬇️

```zig
pub fn syscall1(number: usize, arg1: usize) usize {
    return asm volatile ("syscall"
        : [ret] "={rax}" (-> usize),
        : [number] "{rax}" (number),
          [arg1] "{rdi}" (arg1),
        : .{ .rcx = true, .r11 = true });
}
```

自动升级可使用 `zig fmt`。

### 允许 @ptrCast 从单项指针转换为切片

这是对 0.14.0 版本中 `@ptrCast` 支持切片长度转换特性的扩展。现在它还可以将单项指针转换为任意切片，返回一个引用与原始指针字节数相同的切片。

```zig ptrcast-single.zig
const std = @import("std");

test "value to byte slice with @ptrCast" {
    const val: u32 = 1;
    const bytes: []const u8 = @ptrCast(&val);
    switch (@import("builtin").target.cpu.arch.endian()) {
        .little => try std.testing.expect(std.mem.eql(u8, bytes, "\x01\x00\x00\x00")),
        .big => try std.testing.expect(std.mem.eql(u8, bytes, "\x00\x00\x00\x01")),
    }
}
```

```sh
$ zig test ptrcast-single.zig
1/1 ptrcast-single.test.value to byte slice with @ptrCast...OK
All 1 tests passed.
```

注意，未来计划将此能力从 `@ptrCast` 移至新的 `@memCast` 内建函数，后者在设计上更安全，有助于避免意外越界访问。详情请见 [issue #23935](https://github.com/ziglang/zig/issues/23935)。

### undefined 上的算术操作新规则

Zig 0.15.x 开始规范 `undefined` 在不同场景下的行为，特别是在参与算术运算时的规则。简言之，只有那些永远不会导致非法行为的运算符才允许 `undefined` 作为操作数。其它情况，若操作数为 `undefined`，将触发非法行为（运行时报错）或编译时报错。

通用的最佳实践是：_始终避免对 `undefined` 进行任何操作_。这样一来，这一语言变更（及未来相关变动）基本不会影响你的代码。如果你受到了此项语言变更影响，你可能会在原本可以编译的代码上见到类似的报错：

```zig arith-on-undefined.zig
const a: u32 = 0;
const b: u32 = undefined;

test "arithmetic on undefined" {
    // 此处加法现在会报错
    _ = a + b;
    // 解决方式就是直接避免该操作！
}
```

```sh
$ zig test arith-on-undefined.zig
src/download/0.15.1/release-notes/arith-on-undefined.zig:6:13: error: use of undefined value here causes illegal behavior
    _ = a + b;
            ^
```

### 整数到浮点的损失性转换会导致编译报错

这类报错本就预期存在，只是直到现在才实现。若某整数值在 `comptime` 被强制转换为浮点类型，但该整数无法被该浮点数精确表示，则编译器现在会报错。例如：

```zig lossy_int_to_float_coercion.zig
test "big float literal" {
    const val: f32 = 123_456_789;
    _ = val;
}
```

```sh
$ zig test lossy_int_to_float_coercion.zig
src/download/0.15.1/release-notes/lossy_int_to_float_coercion.zig:2:22: error: type 'f32' cannot represent integer value '123456789'
    const val: f32 = 123_456_789;
                     ^~~~~~~~~~~
```

通常的解决办法是将整数字面量改为浮点字面量，以此显式加入浮点数的舍入规则：

```zig lossy_int_to_float_coercion_new.zig
test "big float literal" {
    const val: f32 = 123_456_789.0;
    _ = val;
}
```

```sh
$ zig test lossy_int_to_float_coercion_new.zig
1/1 lossy_int_to_float_coercion_new.test.big float literal...OK
All 1 tests passed.
```

## 标准库

未归类的变更：

- `fs.Dir.copyFile` 不再会因 `error.OutOfMemory` 失败
- `fs.Dir.atomicFile` 现在要求在选项中带有 `write_buffer`
- `fs.AtomicFile` 现在有一个 `File.Writer` 字段，而不是 `File` 字段
- `fs.File`：移除了 `WriteFileOptions`、`writeFileAll`、`writeFileAllUnseekable`，统一用 `File.Writer` 替代
- `posix.sendfile` 移除，推荐使用 `fs.File.Reader.sendFile`

### Writer 变动

[上一次相关变革（Allocgate）](https://ziglang.org/download/0.9.0/release-notes.html#Allocgate)

所有现有的 `std.io` reader 和 writer 都已弃用，推荐使用全新的 `std.Io.Reader` 和 `std.Io.Writer`。这些新接口是非泛型（non-generic）的，缓冲区（buffer）在 vtable 之上。换句话说，缓冲区属于接口本身，而不是实现。这意味着 Reader 和 Writer 虽然不再是泛型类型，但在优化时依然透明：接口函数都针对 buffer 有明确的热路径，只有缓冲区满了才会触发 vtable 调用。

这些更改极其破坏性，对于此我表示歉意，但我已经仔细权衡，并对这个方向充满信心。希望你能系好安全带，和 Zig 一起前行，这会物有所值。

#### 变更动机

[Systems Distributed 2025 演讲：Don't Forget To Flush](https://www.youtube.com/watch?v=f30PceqQWko)

- 老接口是泛型的，污染了包含它们的结构体，并导致所有相关函数都要用 `anytype` 泛型。新接口是具体类型。
  - 额外好处：类型具体化后，API 不容易直接作用于网络流、文件句柄或内存缓冲区，使代码更加可复用。例如更新后的 `http.Server` 不再依赖 `std.net`，而是仅操作流。
- 老接口传递错误，但没有专用错误集合（error set），造成流的错误和 `anyerror` 类似。新接口为每个函数定义了明确的 error set，每个 error 都有可操作意义。
- 新接口将缓冲区集成进接口本身，而不再用单独的 "BufferedReader"/"BufferedWriter" 抽象。这样对优化器更加友好，特别是在 debug 模式下。
- 新接口支持诸如向量、填充（splatting）、直接文件传输（fd-to-fd）等高级特性，这些可以在读写器图（graph）中传递，减少系统调用、内存带宽和 CPU 使用率。
- 新接口有 "peek" 功能，带来了用户 API 的便利与更简单易实现的实现逻辑。

#### 适配器 API

如果你有旧流接口，需要转到新接口，可以这样写：

```zig
fn foo(old_writer: anytype) !void {
    var adapter = old_writer.adaptToNewApi(&.{});
    const w: *std.Io.Writer = &adapter.new_interface;
    try w.print("{s}", .{"example"});
    // ...
}
```

#### 新的 `std.Io.Writer` 和 `std.Io.Reader` API

这些环形缓冲区（ring buffer）有一组更方便、性能更好且非泛型的新 API。例如这样读取分隔符：

```zig
while (reader.takeDelimiterExclusive('\n')) |line| {
    // 处理每行...
} else |err| switch (err) {
    error.EndOfStream, // 流未以换行结尾
    error.StreamTooLong, // 行过长，缓冲不下
    error.ReadFailed, // 可从实现中进一步诊断
    => |e| return e,
}
```

和其他语言的流实现相比，Zig 的流还新增了如下独特概念：

- 读取时丢弃（discarding）：可高效跳过数据。例如解压流在被请求丢弃大量数据时，可以直接跳过整个 frame。
- 写入时填充（splatting）：等同逻辑上的 `memset`，能在管道中无数据拷贝直接传递，将 O(M\*N) 操作变成 O(M)，有时（比如写入零）还能优化到直接 seek 跳过。
- 写入时传送整个文件：支持 I/O 管道在操作系统支持时直接 fd-to-fd 拷贝文件。
- 用户负责提供缓冲区，流实现决定最小缓冲区大小，等于把部分状态从实现转移到用户所提供的 buffer 上。

#### `std.fs.File.Reader` 和 `std.fs.File.Writer`

`std.fs.File.Reader` 会缓存（memoize）文件句柄的关键信息：

- `stat` 得到的大小，或相关错误
- 当前 seek 位置
- 尝试 seek 时发生的错误
- 是否应定位（positional）读取
- 是否通过 fd-to-fd（如 `sendfile`）系统调用读取，亦或普通方式

该类型实现了 `std.Io.Reader` 接口。

实际用起来非常方便。有一个具体类型缓存文件大小等信息十分好用。大部分原本在文件句柄上操作 seek 的代码应迁移到这个 API，由于定位读取的优化，往往会变成无操作（no-op），同时仍支持回退到流式读。

`std.fs.File.Writer` 意义类似，用于写操作。

#### 升级 `std.io.getStdOut().writer().print()`

务必使用缓冲！而且别忘记 flush！

```zig
var stdout_buffer: [1024]u8 = undefined;
var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
const stdout = &stdout_writer.interface;

// ...

try stdout.print("...", .{});

// ...

try stdout.flush();
```

#### `std.compress.flate` 重构

`std.compress` 的 API 全面重组了 flate，包括 zlib 和 gzip。现在主 API 是 `std.compress.flate.Decompress`，需要传 container 参数。

新 API 示例：

```zig
var decompress_buffer: [std.compress.flate.max_window_len]u8 = undefined;
var decompress: std.compress.flate.Decompress = .init(reader, .zlib, &decompress_buffer);
const decompress_reader: *std.Io.Reader = &decompress.reader;
```

如果 `decompress_reader` 会被整个写入某个 `*Writer`，可以用空缓冲：

```zig
var decompress: std.compress.flate.Decompress = .init(reader, .zlib, &.{});
const n = try decompress.streamRemaining(writer);
```

压缩功能已被移除。如需相关逻辑，请直接复制老代码到你的应用，或用第三方包。

未来会把 deflate 加回 Zig 标准库。但目前语言进展优先于标准库，本次变更也是为最终锁定[以 I/O 为接口的设计](https://ziglang.org/download/0.15.1/release-notes.html#IO-as-an-Interface)做准备。

特别说明：

- 新实现不再计算校验和（check sum），可由外部实现。
- 新实现用普通 for 循环取代了之前复杂的匹配（match）逻辑。未来希望能有专用内存拷贝工具，zstd 也可用。即便如此，实际 untar 过程快 10%，编译器自身代码减小 2%（见 #24614）。

#### CountingWriter 已删除

- 需要丢弃字节时，请用 `std.Io.Writer.Discarding`，它支持计数。
- 需要分配字节时，请用 `std.Io.Writer.Allocating`，它能查询已分配字节数。
- 写入固定缓冲区时，用 `std.Io.Writer.fixed`，然后查询当前指针位置。
- 或者，不要仅为计数字节而构建 stream graph 新节点，这会破坏高效缓冲。

#### BufferedWriter 已删除

```zig
const stdout_file = std.fs.File.stdout().writer();
var bw = std.io.bufferedWriter(stdout_file);
const stdout = bw.writer();

try stdout.print("Run `zig build test` to run the tests.\n", .{});

try bw.flush(); // 别忘记 flush！
```

⬇️

```zig
var stdout_buffer: [4096]u8 = undefined;
var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
const stdout = &stdout_writer.interface;

try stdout.print("Run `zig build test` to run the tests.\n", .{});

try stdout.flush(); // 别忘记 flush！
```

建议将 `stdout` 缓冲区写成全局变量。

#### "{f}" 格式要求：必须显式调用 format 方法

开启 `-freference-trace` 可以帮助你排查所有 format 字符串问题。

示例：

```zig
std.debug.print("{}", .{std.zig.fmtId("example")});
```

现在会报如下编译错误：

```sh
error: ambiguous format string; specify {f} to call format method, or {any} to skip it
```

修正为：

```zig
std.debug.print("{f}", .{std.zig.fmtId("example")});
```

动机：消除两个易踩坑点：

- 向结构体添加 format 方法时，如果某处用了 `{}` 会导致行为悄然变化并引发 bug。
- 移除 format 方法时，某处用 `{}` 也会在无提示下改变输出。

现在，如果给结构体加了 format 方法，所有用 `{}` 的地方会直接编译报错，强制你改用 `{f}` 或明确跳过。未来，这种更改不会影响已有代码输出。

同理，移除 format 方法后，所有用 `{}` 的地方行为不会再悄然变化。

总之，用 `{f}` 总是会尝试调用 format 方法，如果不存在，会报错。

#### format 方法不再接受格式字符串或选项参数

之前：

```zig
pub fn format(
    this: @This(),
    comptime format_string: []const u8,
    options: std.fmt.FormatOptions,
    writer: anytype,
) !void { ... }
```

⬇️

现在：

```zig
pub fn format(this: @This(), writer: *std.Io.Writer) std.Io.Writer.Error!void { ... }
```

被删掉的 `FormatOptions` 现只用于数字类型。

原来依赖格式字符串的代码可选三种改法：

- 定义不同的格式化方法

```zig
pub fn formatB(foo: Foo, writer: *std.Io.Writer) std.Io.Writer.Error!void { ... }
```

可用 `{f}`，配合 `. {std.fmt.alt(Foo, .formatB)}` 调用。

- 用 `std.fmt.Alt`

```zig
pub fn bar(foo: Foo, context: i32) std.fmt.Alt(F, F.baz) {
    return .{ .data = .{ .context = context } };
}
const F = struct {
    context: i32,
    pub fn baz(f: F, writer: *std.Io.Writer) std.Io.Writer.Error!void { ... }
};
```

可用 `{f}`，`.{foo.bar(1234)}` 调用。

- 返回实现 format 方法的 struct，再配合 `{f}` 使用

```zig
pub fn bar(foo: Foo, context: i32) F {
    return .{ .context = 1234 };
}
const F = struct {
    context: i32,
    pub fn format(f: F, writer: *std.Io.Writer) std.Io.Writer.Error!void { ... }
};
```

同样支持 `{f}`，`.{foo.bar(1234)}` 调用。

#### 格式化打印不再支持 Unicode

如果你的对齐依赖 Unicode 码点，现在仅支持 ASCII/字节。此前的实现未完全支持 Unicode。如需对齐 Unicode 字符串须用真正的 Unicode 库，标准库暂不支持。

#### 新格式化打印符号

- `{t}` 简写等同于 `@tagName()` 和 `@errorName()`
- `{d}` 及其它整数格式符可用于自定义类型，会调用 `formatNumber` 方法
- `{b64}`：以标准 base64 输出字符串

### 链表类型去泛型

现在没必要自己手写 next/prev 指针，二进制体积也略小。

迁移方式：

原来：

```zig
std.DoublyLinkedList(T).Node
```

变为：

```zig
struct {
    node: std.DoublyLinkedList.Node,
    data: T,
}
```

借助 `@fieldParentPtr` 可通过 node 找到 data。

许多场景更推荐把 node 直接嵌入数据结构（intrusive），如果还没这么做，很可能链表不是最佳选择。

#### std.Progress 支持进度条转义码

[终端支持进度状态的转义码](https://conemu.github.io/en/AnsiEscapeCodes.html#ConEmu_specific_OSC)。

构建系统（Build System）的 `--watch` 能感知失败或成功并反馈终端，等待用户输入时也会清除进度条。

std.Progress 新增 `setStatus` 方法及如下枚举：

```zig
pub const Status = enum {
    /// 程序正在执行任务
    working,
    /// 程序操作完成，等待用户输入（不直接 exit(0)）
    success,
    /// 程序发生错误，等待用户输入（不直接 exit(1)）
    failure,
    /// 程序有错误但还在工作
    failure_working,
};
```

#### HTTP 客户端与服务端

相关 API 和实现已完全重写。

服务端 API 不再依赖 std.net，只依赖 std.Io.Reader / std.Io.Writer，且可以发无限数量的 header。

原本：

```zig
var read_buffer: [8000]u8 = undefined;
var server = std.http.Server.init(connection, &read_buffer);
```

现在：

```zig
var recv_buffer: [4000]u8 = undefined;
var send_buffer: [4000]u8 = undefined;
var conn_reader = connection.stream.reader(&recv_buffer);
var conn_writer = connection.stream.writer(&send_buffer);
var server = std.http.Server.init(conn_reader.interface(), &conn_writer.interface);
```

服务端和客户端都共享 `std.http.Reader` 与 `std.http.BodyWriter`，同样只依赖 I/O 流，不依赖网络。

客户端升级例子：

原本：

```zig
var server_header_buffer: [1024]u8 = undefined;
var req = try client.open(.GET, uri, .{
    .server_header_buffer = &server_header_buffer,
});
defer req.deinit();

try req.send();
try req.wait();

const body_reader = try req.reader();
// read from body_reader...

var it = req.response.iterateHeaders();
while (it.next()) |header| {
    _ = header.name;
    _ = header.value;
}
```

现在：

```zig
var req = try client.request(.GET, uri, .{});
defer req.deinit();

try req.sendBodiless();
var response = try req.receiveHead(&.{});

// 调用 reader() 后，response.head 内字符串无效
var it = response.head.iterateHeaders();
while (it.next()) |header| {
    _ = header.name;
    _ = header.value;
}

// 具体缓冲区大小应根据 reader 用法选择
var reader_buffer: [100]u8 = undefined;
const body_reader = response.reader(&reader_buffer);
```

### TLS 客户端

std.crypto.tls.Client 不再依赖 std.net 或 std.fs，仅依赖 std.Io.Reader / std.Io.Writer。

### ArrayList 默认无管理（unmanaged）

- std.ArrayList -> std.array_list.Managed
- std.ArrayListAligned -> std.array_list.AlignedManaged

注意：这两个类型最终都会被移除。

有 allocator 字段的 ArrayList 比没有更复杂，没必要。拥有 allocator 的 ArrayList 主要优势：

- 避免用错 allocator
- 某些地方方便传递 allocator

但缺点是：

- 方法签名更复杂
- 无法静态初始化
- 更多内存占用（尤其嵌套容器时）

最终：这些优点不值得。正确的 allocator 总是易得，也易于检查，只有一种实现更简单。实践中老用户对此很欢迎。

### 环形缓冲区（ring buffer）

[标准库环形缓冲区实现太多了！](https://github.com/ziglang/zig/issues/19231)

- `std.fifo.LinearFifo` 被移除——设计不佳，过度泛型，各种管理策略本质完全不同。
- 绝大多数实际用途已被新 `std.Io.Writer` / `std.Io.Reader` API 覆盖。
- `std.RingBuffer` 仅被 zstd 用，也已更换为新 API，被移除。
- `std.compress.flate.CircularBuffer`（flate 内部用）已删除。
- [HTTP Client 与 Server](https://ziglang.org/download/0.15.1/release-notes.html#HTTP-Client-and-Server) 也各有一个，也被删除并统一用新 API。

即便如此还会冒出环形缓冲区实现，比如：

- lib/std/compress/lzma/decode/lzbuffer.zig（lzma 专用）
- lib/std/crypto/tls.zig —— 新 API 已替代
- lib/std/debug/FixedBufferReader.zig —— 新 API 已替代
- [某个随机 PR](https://github.com/ziglang/zig/issues/19231)

玩笑归玩笑，未来标准库可能有通用可靠的 ring buffer，但请先问问你是否只需要 `std.Io.Reader` 或 `std.Io.Writer`。

### BoundedArray 被移除

这种结构因易于拷贝而流行，但带来隐藏成本。

升级建议，根据容量上限来源分类：

- 如果是任意值，仅作为能力上限建议，不要猜。让调用方传入缓冲区 slice 或用动态分配。（例：#24699 里的 markdown）
- 如果只是栈上有限容量的类型安全，直接用 `ArrayListUnmanaged`。很方便！（例：#24699 的 test_switch_dispatch_loop.zig）

`std.ArrayList` 现在所有 "AssumeCapacity" 的方法都有 "Bounded" 变体：

原本：

```zig
var stack = try std.BoundedArray(i32, 8).fromSlice(initial_stack);
```

现在：

```zig
var buffer: [8]i32 = undefined;
var stack = std.ArrayListUnmanaged(i32).initBuffer(&buffer);
try stack.appendSliceBounded(initial_stack);
```

- 如果是有固定最大容量的有序集合，这很少见，直接自己编码管理就好。（例：#24699 Zcu.zig）
- 如果是用作可复制的可增长数组？那会无谓地到处复制未定义内存和增加泛型膨胀，建议不用。

### 删除和弃用内容

- std.fs.File.reader -> std.fs.File.deprecatedReader
- std.fs.File.writer -> std.fs.File.deprecatedWriter
- std.fmt.fmtSliceEscapeLower -> std.ascii.hexEscape
- std.fmt.fmtSliceEscapeUpper -> std.ascii.hexEscape
- std.zig.fmtEscapes -> std.zig.fmtString
- std.fmt.fmtSliceHexLower -> {x}
- std.fmt.fmtSliceHexUpper -> {X}
- std.fmt.fmtIntSizeDec -> {B}
- std.fmt.fmtIntSizeBin -> {Bi}
- std.fmt.fmtDuration -> {D}
- std.fmt.fmtDurationSigned -> {D}
- std.fmt.Formatter -> std.fmt.Alt
  - 现在需显式指定 context 类型
  - 无 fmt 字符串参数
- std.fmt.format -> std.Io.Writer.print
- std.io.GenericReader -> std.Io.Reader
- std.io.GenericWriter -> std.Io.Writer
- std.io.AnyReader -> std.Io.Reader
- std.io.AnyWriter -> std.Io.Writer
- 删除 std.io.SeekableStream
  - 请用 *std.fs.File.Reader、*std.fs.File.Writer 或具体的 std.ArrayListUnmanaged，根据场景选取实现方式
- 删除 std.io.BitReader
  - 不建议此层面抽象位读取，会妨碍热循环的性能优化，请与流实现紧密耦合
- 删除 std.io.BitWriter
  - 同上
- 删除 std.Io.LimitedReader
- 删除 std.Io.BufferedReader
- 删除 std.fifo

## 构建系统

未归类的变更：

- zig build: 在构建总结前输出一个换行

### 移除旧的 root_module 字段

Zig 0.14.0 新增了 `root_module` 字段到 `std.Build.ExecutableOptions` 及相关 API，同时废弃了此前用来指定主模块的字段 `root_source_file` 等。在 Zig 0.15.x 中，这些旧字段已被彻底移除。如果你没有在上一版本周期内迁移代码，现在会遇到类似如下的编译错误：

```zig deprecated-addExecutable.zig
pub fn build(b: *std.Build) void {
    const exe = b.addExecutable(.{
        .name = "foo",
        .root_source_file = b.path("src/main.zig"),
        .target = b.graph.host,
        .optimize = .Debug,
    });
    b.installArtifact(exe);
}

test {
    _ = &build;
}
const std = @import("std");
```

```sh Shell
$ zig test deprecated-addExecutable.zig
src/download/0.15.1/release-notes/deprecated-addExecutable.zig:4:10: error: no field named 'root_source_file' in struct 'Build.ExecutableOptions'
        .root_source_file = b.path("src/main.zig"),
         ^~~~~~~~~~~~~~~~
/home/ci/deps/zig-x86_64-linux-0.15.1/lib/std/Build.zig:771:31: note: struct declared here
pub const ExecutableOptions = struct {
                              ^~~~~~
referenced by:
    test_0: src/download/0.15.1/release-notes/deprecated-addExecutable.zig:12:10
```

关于如何迁移旧代码，请参考 [Zig 0.14.0 发布说明对应章节](https://ziglang.org/download/0.14.0/release-notes.html#Creating-Artifacts-from-Existing-Modules)。

### macOS 文件系统监听

现在，`zig build` 的 `--watch` 参数已支持 macOS 系统。在 Zig 0.14.0 时，这个参数虽然可用，但对大多数编辑器表现异常；而在 Zig 0.15.x 里，这一功能已被[重新实现](https://github.com/ziglang/zig/pull/24649)，采用了 macOS 的 File System Events API，确保文件系统变更监听快速且可靠。

所以，如果此前因 macOS 问题没有使用 `--watch`，现在可以放心使用了。尤其是你想试用 [增量编译](https://ziglang.org/download/0.15.1/release-notes.html#Incremental-Compilation) 时，推荐为 `zig build` 传递 `--watch -fincremental`。

### Web 界面与时间报告

Zig 0.14.0 提供了用于内置模糊测试 fuzzer 的实验性 Web 界面。在 0.15.x 中，这一界面被扩展为更通用的构建系统 Web 界面。可通过 `zig build --webui` 选项启用。启用后，`zig build` 进程会在构建完成后持续运行。

Web 界面本身主要显示所有构建步骤及其状态，同时有按钮可手动触发重新构建（所以可以作为 `zig build --watch` 流程的替代方式）。如果使用 `--fuzz`，则会暴露 [Fuzzer](https://ziglang.org/download/0.15.1/release-notes.html#Fuzzer) 相关界面，其内容与 0.14.0 基本一致。

此外，Web 界面新增了“时间报告”功能。只需为 `zig build` 传递 `--time-report`，即可在 Web 界面上展开查看构建图中各步骤的耗时信息。尤其是每个 `std.Build.Step.Compile`，都会有详细的子阶段统计：Zig 编译器各部分的快慢情况，以及哪些文件/声明在语义分析、生成机器码、链接阶段消耗的时间最多。

![](https://ziglang.org/download/0.15.1/release-notes/build-webui.png)

这是一项较高级别的功能，非常适合定位导致编译变慢的代码片段——只需展开 "Declarations" 表格，查看最耗时的前几项。

![](https://ziglang.org/download/0.15.1/release-notes/build-webui-time-report.png)

如果本次编译用到了 LLVM 后端，还会额外提供 LLVM pass 分阶段的耗时信息。

## Compiler

### x86 后端

**Zig 0.15.x 版本在 Debug 模式下默认启用了 Zig 自实现（self-hosted）的 x86_64 代码生成后端。**

更具体来说，现在只要目标架构是 x86_64 并且使用 Debug 模式，默认都会启用该后端（除了 NetBSD、OpenBSD 和 Windows，这几个平台目前因为 [链接器](https://ziglang.org/download/0.15.1/release-notes.html#Linker) 存在缺陷，仍然默认使用 LLVM 后端）。

启用自实现 x86_64 后端后，你将可以直接感受到 Zig 项目过去几年投入的成果：编译速度显著提升——大多数场景下比 LLVM 快了大约 5 倍。**而这还只是开始**；自实现 x86_64 后端是专为 [增量编译](https://ziglang.org/download/0.15.1/release-notes.html#Incremental-Compilation) 而设计的，这项功能足够稳定时，预计还会有极大加速。极致的编译速度一直是 Zig 项目的核心目标之一，我们已经默默推进多年，这次发布是阶段性成果的集中体现。

使用自实现 x86 后端，还能避免受上游 LLVM Bug 的影响（目前我们[正在跟踪 60 多个相关 Bug](https://github.com/ziglang/zig/issues?q=is%3Aissue%20state%3Aopen%20label%3Abackend-llvm%20label%3Aupstream)）。事实上，自实现 x86 后端在我们的“行为测试集”上，已能通过比 LLVM 后端更多的用例（1984/2008，相比 LLVM 的 1977/2008）。换句话说，该后端对 Zig 语言的实现更为完整和准确。

当然，目前自实现 x86 后端本身也还[存在部分缺陷和 Bug](https://github.com/ziglang/zig/issues?q=is%3Aissue%20state%3Aopen%20label%3Abackend-self-hosted%20label%3Aarch-x86_64)。如果你遇到了相关问题，可以通过命令行参数 `-fllvm`，或在创建 `std.Build.Step.Compile` 时设置 `.use_llvm = true`，将 Debug 编译切换回 LLVM 后端。此外，当前自实现 x86 后端生成的机器码在性能上[略慢于 LLVM 后端](https://github.com/ziglang/zig/issues/24144)。

尽管如此，在绝大多数开发场景中，自研后端已经是更优秀的选择。比如 Zig 核心开发团队已经在很长一段时间内，主要用自研 x86 后端编译 Zig 编译器，极大提升了开发效率，现在 Zig 编译器只需几秒即可构建完成，而以往用 LLVM 则要 1-2 分钟。你也可以期待在自己项目的开发体验中获得类似提升。

### aarch64 后端

在自实现 [x86 后端](https://ziglang.org/download/0.15.1/release-notes.html#x86-Backend) 已经足够成熟并启用为默认后，Jacob 将目标转向了新的架构：aarch64。该架构近年来越来越受欢迎，尤其是现代苹果电脑都基于它。因此，aarch64 成为了 Zig 项目在摆脱 LLVM 依赖的自研代码生成后端中的下一个重点。

这个后端目前还在开发早期阶段，Jacob 已经能基于 x86 后端的经验，尝试全新的设计思路。虽然现在下结论还为时过早，但我们预计新设计将进一步提升编译器性能（甚至有望超越自实现 x86_64 后端），并提升输出机器码的质量，最终目标是在 Debug 模式下与 LLVM 的代码生成质量一较高下。你可以在这篇 [开发日志](https://ziglang.org/devlog/2025/#2025-07-23) 里看到更多细节。

目前该后端已通过了 1656/1972（84%）项与 LLVM 行为一致性的测试，因此还未准备好作为默认后端启用，在实际项目中也暂时无法使用。但它正在快速进步，预计将在未来版本成为 Debug 模式下的默认选择。

我们自实现代码生成后端的工作，是 Zig 长期计划的一部分，未来将 [使 LLVM 成为可选依赖](https://kristoff.it/blog/zig-new-relationship-llvm/)，并[从编译器实现中解耦](https://github.com/ziglang/zig/issues/16270)。实现这一目标将显著提升编译速度，为 Debug 构建带来优秀的增量编译支持，甚至有可能探索 LLVM 无法高效支持的新语言特性。

### 增量编译（Incremental Compilation）

Zig 0.15.x 在正在开发中的增量编译（Incremental Compilation）功能上又取得了进展。该功能允许编译器只重新编译修改过的代码，从而极大提升二次编译的速度。包括文件导入变更相关的各种 Bug 在此版本中均有所修复。

请注意，这依然属于实验性功能——目前仍有已知 Bug，可能导致错误编译或错误的编译报错。但现在已经足够稳定，可以与 `-fno-emit-bin` 结合起来可靠使用。**如果你有一个编译时间很长的庞大项目，非常建议结合使用 `--watch`、`-fincremental` 和 `-Dno-bin` 来改善编译反馈体验。**如果你不清楚如何在构建脚本里暴露 `-Dno-bin`，可以寻求社区帮助。

接下来的发布周期还会继续努力，目标是将增量编译默认开启。如果你有兴趣尝鲜，可以参考 [#21165](https://github.com/ziglang/zig/issues/21165) 了解详情。

### 多线程代码生成（Threaded Codegen）

Zig 编译器自设计之初就考虑到了并行化。通过让编译的不同阶段在多个线程间并行运行，显著提升了编译性能。Zig 早期还是主要单线程的，但从 0.14.0 版本起，部分底层代码生成后端已经能够与前端（语义分析阶段）并发执行。Zig 0.15.x 在此基础上更进一步，实现了语义分析、代码生成、链接这几个阶段可完全并行，且代码生成本身还能进一步拆分到多个线程中去。

与 0.14.0 相比，开启自实现后端（如 x86 后端）后，这一改进通常会带来一次明显的编译性能提升。具体提升幅度与你编译的代码结构有关，有时变化不大，有时提升可高达 50%。举个实际例子：在某台机器上，使用自实现 x86_64 后端编译 Zig 编译器，耗时从 13.8 秒降到了 10.0 秒，提升了 27%。

[这份开发日志](https://ziglang.org/devlog/2025/#2025-06-14) 有更深入的技术细节。总之，得益于各阶段并行执行，当你使用自研后端时，编译速度会得到显著提升。[而且现在终端会显示更详细的进度信息。](https://asciinema.org/a/bgDEbDt4AkZWORDX1YBMuKBD3)

### 支持在模块级别配置 UBSan 模式

现在 Zig CLI 和构建系统允许更灵活地控制 C 兼容未定义行为检测（UBSan）模式。`zig build-exe` 及相关命令现支持 `-fsanitize-c=trap` 和 `-fsanitize-c=full`，其中旧的 `-fsanitize-c` 就等价于 `-fsanitize-c=full`。

- 选择 `full` 时，UBSan 运行时会被编译并链接进你的程序，遇到未定义行为时提供更详尽的错误信息，但相应代码体积会略大。
- 选择 `trap` 时，会插入陷阱指令，触发未定义行为时进程会收到 `SIGILL`，但是代码体积更小。
  如未显式指定，默认模式由构建模式决定。

对于 [zig cc](https://ziglang.org/download/0.15.1/release-notes.html#zig-cc)，在已有的 `-fsanitize=undefined` 外，现在也能理解 `-fsanitize-trap=undefined`，与 `zig build-exe` 上的 `-fsanitize-c=trap` 基本等价。

因为本次变更，`std.Build` API 里的 `sanitize_c` 字段类型从 `?bool` 替换成了 `?std.zig.SanitizeC`。如果你过去设置为 `true/false`，现在应分别切换为 `.full` 或 `.off`，以保持原有行为。

### 测试编译为对象文件（Compile Tests to Object File）

通常，Zig 的测试功能会直接构建一个可执行文件。但有些场景下，你可能需要只生成测试用的对象文件而非最终可执行文件，比如让外部代码以共享库方式加载你的应用。Zig 0.15.x 针对这些需求，允许测试生成对象文件，便于后续以你希望的方式进行链接。

命令行下，可通过运行 `zig test-obj`（而不是 `zig test`）实现。

使用构建系统时，可通过新版 `std.Build` API，在调用 `std.Build.addTest` 时传递 `emit_object` 选项，这样返回的 `Step.Compile` 会生成对象文件。这个对象文件和其他对象一样，可以被安装用于外部使用，或直接链接到其他 build 步骤。不过注意：启用此功能后，build runner 与 test runner 不会直接通信，退回到默认的 `zig test` 方式（即用 stderr 报告测试失败）。所以如果你用到这个特性，可能还需自定义 test runner，让它能与外部测试框架协作。

### Zig Init

`zig init` 命令在本版本中配备了新版项目模板。

旧模板包含用于生成 Zig 模块静态库的代码，这容易让初学者误以为“生成静态库”是 Zig 代码复用的首选方式。

新的项目模板则同时提供了 Zig 模块与可执行文件的样板代码。这符合大多数开发需求，同时也展示了如何将可复用逻辑拆分到模块中、并在应用中进行调用。如果你只需生成单一类型的产物，可以直接删除不需要的部分。而保留这些内容也能温和地提醒你：

- 为你的库设计配套工具
- 在你的可执行文件中方便地访问可复用逻辑

现在你可以通过在 `zig init` 命令后加上 `--minimal` 或 `-m` 参数，生成极简模板。执行该命令会创建 `build.zig.zon` 文件，并在不存在时，创建仅包含 `build` 函数框架的 `build.zig` 文件。这个选项适用于已经熟悉 Zig 构建系统且主要希望方便生成带有正确指纹的 Zon 文件的用户。

## 链接器（Linker）

在本次发布周期中，Zig 的链接器仅进行了部分 Bug 修复与维护。但请注意，链接器将在[下一个发布周期](https://ziglang.org/download/0.15.1/release-notes.html#Roadmap)成为重点优化对象，目标是进一步改进增量编译（Incremental Compilation）相关体验。

## Fuzzer（模糊测试器）

尽管核心团队一直对模糊测试保持极大热情，但在本发布周期内，团队成员未能投入足够精力推动 fuzzer 的进一步发展。我们在此感谢贡献者 Kendall Condon，他提交了一个 pull request [大幅提升 fuzzer 能力](https://github.com/ziglang/zig/pull/23416)，目前正在耐心等待核心团队的后续协作。

## Bug 修复

[点此查看本次发布周期内关闭的 201 个 bug 报告的完整列表。](https://github.com/ziglang/zig/issues?q=is%3Aclosed+is%3Aissue+label%3Abug+milestone%3A0.15.0)

在本次发布周期内，新的 bug 持续被发现和修复。为了简洁起见，绝大多数 bug 修复未在本发行说明中详细列出。

## 本版本仍然存在已知缺陷

Zig 依然有[已知 bug](https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Abug)、[误编译问题](https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Amiscompilation)和[回归缺陷](https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Amiscompilation)。

即使使用 Zig 0.15.x，在较复杂的项目中工作，也可能需要你主动参与到开发流程当中，一起反馈和解决问题。

当 Zig 进入 1.0.0 正式版后，Tier 1 支持将会增加专门的 bug 管理政策作为强制要求。

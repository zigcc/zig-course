---
outline: deep
comments: false
---

# `0.12.0`

2024/4/20，`0.12.0` 终于发布了，历时 8 个月，有 268 位贡献者，一共进行了 3688 次提交！

> 过去的发行说明都异常的长，因为试图记录所有在开发周期中所有的变化，本次更新则进行了适当地删减，便于读者和维护者阅读！

::: info

注意： 存在一部分变动并未在本次的发行说明中提及，其中包括 API 的 `Break Change`。

:::

TODO: 增加四层支持的变化说明！

## 语言变动

`0.12.0` 进行一些语言方面的变动，以下是详细说明！

### 非必要不使用 `var`

引入了一个新的编译错误，当局部变量声明为 `var` 但使用 `const` 就足够时，编译器会发出该错误！

```zig
const expectEqual = @import("std").testing.expectEqual;
test "unnecessary use of var" {
    var x: u32 = 123;
    try expectEqual(123, x);
}
```

```sh
$ zig test unnecessary_var.zig
docgen_tmp/unnecessary_var.zig:3:9: error: local variable is never mutated
    var x: u32 = 123;
        ^
docgen_tmp/unnecessary_var.zig:3:9: note: consider using 'const'
```

解决该错误也很简单，使用 `const` 即可！

### 结果位置语义

对结果位置语义 _Result Location Semantics (RLS)_ 的多项增强。

::: info

结果位置语义是Zig语言中的一个特性，它影响函数如何返回结果和错误。

:::

结果类型（result types）可以通过取地址运算符（`&`）进行传递。这允许依赖结果类型的语法结构，如匿名初始化 `.{ ... }` 和像 `@intCast` 这样的转换内建函数，在存在取地址运算符的情况下正确地工作。这是一种新的特性，可以使代码在处理结果类型时更加灵活和准确。

```zig
const S = struct { x: u32 };
const int: u64 = 123;
const val: *const S = &.{ .x = @intCast(int) };
comptime {
    _ = val;
}
```

::: info

此外，在这个版本中，结果位置（**result locations**）不能通过@as和明确类型的聚合初始化T{ ... }进行传播。这个限制是为了简化语言设计。在之前的版本中，有几个关于结果指针（result pointers）错误转换的 bug，这个更改就是为了解决这些问题。

:::

### 解构语法（Aggregate Destructuring）

引入了新语法，允许对可索引的聚合结构（如元组、向量和数组）进行解构。在赋值操作的左侧编写一系列的左值或本地变量声明，将尝试解构右侧指定的值。这是一种新的赋值方式，可以更方便地从聚合结构中提取值：

```zig
var z: u32 = undefined;
const x, var y, z = [3]u32{ 1, 2, 3 };
y += 10;
// x 是 1，y 是 12，z 是 3

const x, const y = @Vector(2, u32){ 1, 2 };
// 编译期的值也会进行解构，x 是 1，y 是 2

var runtime: u32 = undefined;
runtime = 123;
const x, const y = .{ 42, runtime };
// 当然，编译期和运行时的值也会被正确解析
// x 是编译期可以知道的值 42
// y 是运行时可知的值 123

```

::: warning

**切片**（slices）不能直接被解构，如果想从切片中解构值，需要将它转换为数组，方法是使用编译时已知的边界进行切割，例如 `slice[0..3].*`。这样，就可以像处理数组一样处理切片，从而实现解构。

:::

### 命名空间类型等价性

在Zig中，结构体（`struct`）、枚举（`enum`）、联合体（`union`）和不透明类型（`opaque types`）是特殊的，它们不像元组和数组那样使用结构等价性，而是创建独特的类型。这些类型有命名空间，因此可能包含声明，它们可以统称为"命名空间类型"。

在 `0.11.0` 版本中，每次这样的类型声明被语义分析时，都会创建一个新的类型。泛型类型的等价性是通过对编译时函数调用的记忆化（memoization）来处理的；也就是说，`std.ArrayList(u8) == std.ArrayList(u8)` 成立，因为 `ArrayList` 函数只被调用一次，其结果被记忆化。

在0.12.0版本中，这一点发生了变化。现在，命名空间类型基于两个因素进行去重：它们的源位置和它们的捕获。

类型的"捕获"指的是它闭包覆盖的编译时已知类型和值的集合。换句话说，它是在类型内部引用但在类型外部声明的值的集合。例如，`std.ArrayList` 的编译时 `T: type` 参数被它返回的类型捕获。如果两个命名空间类型由同一段代码声明并且有相同的捕获，那么它们现在被认为是完全相同的类型。

请注意，编译器仍然会记忆化编译时调用：这一点没有改变。然而，这种记忆化对语言语义的影响已经不再有意义。

这种实现的更改不太可能带来改变，但需要注意以下情况：

```zig
fn MakeOpaque(comptime n: comptime_int) type {
    _ = n;
    return opaque {};
}
const A = MakeOpaque(0);
const B = MakeOpaque(1);
```

在 Zig `0.11.0` 版本中，这段代码会创建两个不同的类型，因为对 `MakeOpaque` 的调用是不同的，因此每次调用都会单独分析不透明声明。而在 `Zig 0.12.0` 版本中，这些类型是相同的（A == B），因为虽然函数被调用了两次，但声明并没有捕获任何值。

要修正这个问题也很简单，强制捕获 `n` 就可以了：

```zig
fn MakeOpaque(comptime n: comptime_int) type {
    return opaque {
        comptime {
            _ = n;
        }
    };
}
const A = MakeOpaque(0);
const B = MakeOpaque(1);
```

由于 `n` 被 `opaque` 强制引用，将会产生两个不同的类型！

### 编译期内存变化

对编译器的编译时内存（comptime memory）的内部表示，特别是编译时可变内存（即 `comptime var`）进行了全面改革。这次改革带来了一些面向用户的变化，以新的限制的形式出现，限制了你可以对 `comptime var` 做什么。

第一个也是最重要的新规则是，永远不允许指向 a comptime var 的指针成为运行时已知的。例如：

```zig
test "runtime-known comptime var pointer" {
    comptime var x: u32 = 123;
    // `var` 使得 `ptr` 运行时可知
    var ptr: *const u32 = undefined;
    ptr = &x;
    if (ptr.* != 123) return error.TestFailed;
}
```

```sh
$ zig test comptime_var_ptr_runtime.zig
docgen_tmp/comptime_var_ptr_runtime.zig:5:11: error: runtime value contains reference to comptime var
    ptr = &x;
          ^~
docgen_tmp/comptime_var_ptr_runtime.zig:5:11: note: comptime var pointers are not available at runtime
```

在早期版本的 Zig 中，此测试会通过。现在，编译器会报告编译错误，因为对 `ptr` 的赋值使得值 `&x`（这是一个指向 `comptime var` 的指针）变为运行时已知。

例如，通过将这样的指针传递给在运行时调用的函数，这些指针也可以变为运行时已知：

```zig
test "comptime var pointer as runtime argument" {
    comptime var x: u32 = 123;
    if (load(&x) != 123) return error.TestFailed;
}
fn load(ptr: *const u32) u32 {
    return ptr.*;
}
```

```sh
$ zig test comptime_var_ptr_runtime_arg.zig
docgen_tmp/comptime_var_ptr_runtime_arg.zig:3:14: error: runtime value contains reference to comptime var
    if (load(&x) != 123) return error.TestFailed;
             ^~
docgen_tmp/comptime_var_ptr_runtime_arg.zig:3:14: note: comptime var pointers are not available at runtime
```

现在，这个测试也会发出一个编译错误。`load` 的调用发生在运行时，它的 `ptr` 参数没有标记为 `comptime`，所以在 `load` 的主体内，`ptr` 是运行时已知的。这意味着调用 `load` 使得指针 `&x` 在运行时已知，因此产生了编译错误。

这个限制是为了修复一些反直觉的错误。当一个指向comptime var的指针变为运行时已知时，对它的修改变得无效，因为指向的数据变为常量，但类型系统没有反映这一点，导致在看似有效的代码中可能出现运行时段错误。此外，你在运行时从这样的指针读取的值将是它的"最终"编译时值，这是一种不直观的行为。因此，这些指针不能再是运行时已知的。

第二个新的限制是一个指向 `comptime var` 的指针永远不允许包含在全局声明的解析值中。例如：

```zig
const ptr: *const u32 = ptr: {
    var x: u32 = 123;
    break :ptr &x;
};
comptime {
    _ = ptr;
}
```

```sh
$ zig test comptime_var_ptr_global.zig
docgen_tmp/comptime_var_ptr_global.zig:1:30: error: global variable contains reference to comptime var
const ptr: *const u32 = ptr: {
                        ~~~~~^
referenced by:
    comptime_0: docgen_tmp/comptime_var_ptr_global.zig:6:9
    remaining reference traces hidden; use '-freference-trace' to see all reference traces
```

在这里，`ptr` 是一个全局声明，其值是一个指向 `comptime var` 的指针。这个声明在 `0.11.0` 中是允许的，但在 `0.12.0` 中会引发一个编译错误。在更复杂的情况下，同样的规则也适用，例如当指针包含在结构体字段中时：

```zig
const S = struct { ptr: *const u32 };
const val: S = blk: {
    var x: u32 = 123;
    break :blk .{ .ptr = &x };
};
comptime {
    _ = val;
}
```

```sh
$ zig test comptime_var_ptr_global_struct.zig
docgen_tmp/comptime_var_ptr_global_struct.zig:2:21: error: global variable contains reference to comptime var
const val: S = blk: {
               ~~~~~^
referenced by:
    comptime_0: docgen_tmp/comptime_var_ptr_global_struct.zig:7:9
    remaining reference traces hidden; use '-freference-trace' to see all reference traces
```

这段代码引发的编译错误与前一个例子相同。这个限制主要是为了帮助在Zig编译器中实现增量编译，这依赖于全局声明的分析是顺序无关的，以及声明之间的依赖关系可以被轻易地建模。

这种情况最常见的表现形式是在现有代码中出现编译错误，如果一个函数在编译时构造一个切片，然后在运行时使用。例如，考虑以下代码：

```zig
fn getName() []const u8 {
    comptime var buf: [9]u8 = undefined;
    // 在实践中，这里可能会有更复杂的逻辑来填充 buf
    @memcpy(&buf, "some name");
    return &buf;
}
test getName {
    try @import("std").testing.expectEqualStrings("some name", getName());
}
```

```sh
$ zig test construct_slice_comptime.zig
docgen_tmp/construct_slice_comptime.zig:5:12: error: runtime value contains reference to comptime var
    return &buf;
           ^~~~
docgen_tmp/construct_slice_comptime.zig:5:12: note: comptime var pointers are not available at runtime
referenced by:
    decltest.getName: docgen_tmp/construct_slice_comptime.zig:8:64
    remaining reference traces hidden; use '-freference-trace' to see all reference traces
```

调用getName返回一个切片，其ptr字段是一个指向comptime var的指针。这意味着这个值不能在运行时使用，也不能出现在全局声明的值中。这段代码可以通过在填充缓冲区后将计算的数据提升为const来修复：

```zig
fn getName() []const u8 {
    comptime var buf: [9]u8 = undefined;
    // In practice there would likely be more complex logic here to populate `buf`.
    @memcpy(&buf, "some name");
    const final_name = buf;
    return &final_name;
}
test getName {
    try @import("std").testing.expectEqualStrings("some name", getName());
}
```

像在Zig的早期版本中一样，编译时已知的consts具有无限的生命周期，这里讨论的限制不适用于它们。因此，这段代码会正常运行。

另一种可能的失败模式是在使用旧语义创建全局可变编译时状态的代码中。例如，以下片段试图创建一个全局的编译时计数器：

```zig
const counter: *u32 = counter: {
    var n: u32 = 0;
    break :counter &n;
};
comptime {
    counter.* += 1;
}
```

```sh
$ zig test global_comptime_counter.zig
docgen_tmp/global_comptime_counter.zig:1:32: error: global variable contains reference to comptime var
const counter: *u32 = counter: {
                      ~~~~~~~~~^
referenced by:
    comptime_0: docgen_tmp/global_comptime_counter.zig:6:5
    remaining reference traces hidden; use '-freference-trace' to see all reference traces
```

这段代码在 Zig `0.12.0` 中会发出一个编译错误。Zig不支持也不会支持这种用例：任何可变的编译时状态必须在本地表示。

### `@fieldParentPtr`

删除了第一个参数，以支持使用结果类型。

迁移指南：

```zig
const parent_ptr = @fieldParentPtr(Parent, "field_name", field_ptr);
```

变为：

```zig
const parent_ptr: *Parent = @fieldParentPtr("field_name", field_ptr);
```

或者

```zig
const parent_ptr: *Parent = @alignCast(@fieldParentPtr("field_name", field_ptr));
```

这取决于编译器能够证明的父指针对齐。第二种形式更具有可移植性，因为对于某些目标可能需要 `@alignCast` ，而对于其他目标可能不需要。

### 禁止在函数类型上进行对齐

`0.11.0` 允许函数类型指定对齐。在 `0.12.0` 中，这是不允许的，因为它是函数声明和指针的属性，而不是函数类型的属性。

```zig
comptime {
    _ = fn () align(4) void;
}
```

会报告以下错误：

```sh
$ zig test func_type_align.zig
docgen_tmp/func_type_align.zig:2:21: error: function type cannot have an alignment
    _ = fn () align(4) void;
```

### `@errorCast`

过去发布的版本包含了一个 `@errSetCast` 内置函数，它执行从一个错误集到另一个可能更小的错误集的安全检查转换。在 `0.12.0` 中，这个内置函数被 `@errorCast` 替换。它将继续发挥原本的作用，但此外，这个新的内置函数可以转换错误联合类型的错误集：

```zig
const testing = @import("std").testing;

test "@errorCast error set" {
    const err: error{Foo, Bar} = error.Foo;
    const casted: error{Foo} = @errorCast(err);
    try testing.expectEqual(error.Foo, casted);
}

test "@errorCast error union" {
    const err: error{Foo, Bar}!u32 = error.Foo;
    const casted: error{Foo}!u32 = @errorCast(err);
    try testing.expectError(error.Foo, casted);
}

test "@errorCast error union payload" {
    const err: error{Foo, Bar}!u32 = 123;
    const casted: error{Foo}!u32 = @errorCast(err);
    try testing.expectEqual(123, casted);
}
```

### `@abs`

过去的版本包含了 `@fabs` 内置函数。这已被新的 `@abs` 内置函数替换，它能够对整数以及浮点数进行操作。

```zig
const expectEqual = @import("std").testing.expectEqual;

test "@abs on float" {
    const x: f32 = -123.5;
    const y = @abs(x);
    try expectEqual(123.5, y);
}

test "@abs on int" {
    const x: i32 = -12345;
    const y = @abs(x);
    try expectEqual(12345, y);
}
```

## Autodoc 重构

目前我们已经可以使用全新的 `Autodoc`，新的实现带来了更棒的文档阅读体验！

### 旧的实现

文件结构为：

```sh
   5987 src/Autodoc.zig
   435 src/autodoc/render_source.zig
 10270 lib/docs/commonmark.js
  1245 lib/docs/index.html
  5242 lib/docs/main.js
  2146 lib/docs/ziglexer.js
 25325 total
```

编译产物结构（演示使用的标准库文档）为：

```sh
272K commonmark.js
3.8M data-astNodes.js
360K data-calls.js
767K data-comptimeExprs.js
2.2M data-decls.js
896K data-exprs.js
 13K data-files.js
  45 data-guideSections.js
 129 data-modules.js
  15 data-rootMod.js
 294 data-typeKinds.js
3.2M data-types.js
 38K index.html
158K main.js
 36M src/ (470 .zig.html files)
 78K ziglexer.js
```

总输出大小为 **47M**，经过gzip处理后为 **5.7M**！

- `src/Autodoc.zig` 用于处理 ZIR 代码（zig 编译时产生的中间代码），输出 json 以便 js 使用，这就导致很多代码无法通过某些数据（这些数据很可能是无效的），重建 AST 语法树

- `lib/docs/commonmark.js` 是一个第三方的 markdown 实现，但它的特性有点太多了，例如，我们并不希望在文档注释中使用HTML标签，因为这样会让源代码的注释无比丑陋，应当只渲染源代码和 markdown。

- lib/docs/ziglexer.js` 是 js 中针对 zig 的语义标记实现。事实上，zig 已经在标准库中公开了由 zig 实现的语义标记。有趣的是，**andrewrk** 看到这个东西被添加进来的时候应该两眼一黑，具体可以见 [Issue 16306](https://github.com/ziglang/zig/pull/16306) [Issue 16490](https://github.com/ziglang/zig/issues/16490) 。

- `src/autodoc/render_source.zig` 是一种将 `.zig` 文件转换为带有语法高亮但不是交互式的 `.zig.html` 文件。

### 新的实现

文件结构为：

```sh
   942 lib/docs/main.js
   403 lib/docs/index.html
   933 lib/docs/wasm/markdown.zig
   226 lib/docs/wasm/Decl.zig
  1500 lib/docs/wasm/markdown/Parser.zig
   254 lib/docs/wasm/markdown/renderer.zig
   192 lib/docs/wasm/markdown/Document.zig
   941 lib/docs/wasm/main.zig
  1038 lib/docs/wasm/Walk.zig
  6630 total
```

编译产物结构（演示使用的标准库文档）为：

```sh
 12K index.html
 32K main.js
192K main.wasm
 12M sources.tar
```

总输出大小为: **12M**，经过gzip处理后为 **2.3M**！

可以看到，新的实现的代码和产物都很简洁，产物刚刚好只有 4 个文件，并且文件大小直接缩减到了 **1/4** 。

新的实现不仅仅是表面看上去更简单，实际上它较之旧实现更加的强大，因为新的实现并不会处理 ZIR，而是直接读取解析源代码文件（`sources.tar` 就是打包的源代码），这意味着它拥有完整的源代码信息，不需要进行一些乱七八糟的推断。

此方案是使用 zig 编写的 WebAssembly 模块，这允许其重用编译器中的组件，例如分词器，解析器和其他用于对 zig 代码进行操作的一些程序。

通过 HTTP 请求`sources.tar` 文件并解压后，会将其直接送入 Wasm 模块的内存中，针对 tar 文件使用 `std.tar` 进行解析，源代码就地进行解析，并额外进行一些计算添加 hash 表。

针对目前的实现，优化空间可以使用多线程来加速解析，但目前来看单线程已经足够快了，似乎没有必要。

### 携带标准库文档

在 zig 的 `0.11.0` 中，zig 发行时会带有一个 `docs/std/` 目录，其中包含着旧autodoc 实现构建产物（足足 47M 大小）。

在本次重写中，直接删除这些构建产物，作为代替，提供了 `zig std` 命令，这允许使用自带的 autodoc 生成器来打开一个浏览器窗口查看文档说明，首次使用此命令时，会先执行一次针对 `lib/compiler/std-docs.zig` 的编译操作。

HTTP 服务器会动态创建请求的文件，包括 main.wasm 重建（如果任何源文件发生更改）和构造 sources.tar ，这意味着在查看文档时，对文档文件或 autodoc 系统本身的任何源更改都会立即反映出来。在 URL 前面加上 /debug URL 会使用 WebAssembly 模块的调试版本。

这意味着贡献者可以通过在浏览器窗口中按刷新来测试对 Zig 标准库文档以及 autodocs 功能的更改，只需要 Zig 的二进制发行版。

总之，这使的zig的安装大小从 317M 减少到了 268M （-15%）。

编译器的 ReleaseSmall 版本从 10M 缩小到 9.8M （-1%）。

### 构建文档时间

Autodocs 生成现在作为编译器 pipeline 的一部分完成，而不是在最后添加。它也不再依赖于 pipeline 的其他部分。

以下是构建标准库文档所需要的时间：

```sh
Benchmark 1 (3 runs): old/zig test /home/andy/dev/zig/lib/std/std.zig -fno-emit-bin -femit-docs=docs
  measurement          mean ± σ            min … max           outliers         delta
  wall_time          13.3s  ±  405ms    12.8s  … 13.6s           0 ( 0%)        0%
  peak_rss           1.08GB ±  463KB    1.08GB … 1.08GB          0 ( 0%)        0%
  cpu_cycles         54.8G  ±  878M     54.3G  … 55.8G           0 ( 0%)        0%
  instructions        106G  ±  313K      106G  …  106G           0 ( 0%)        0%
  cache_references   2.11G  ± 35.4M     2.07G  … 2.14G           0 ( 0%)        0%
  cache_misses       41.3M  ±  455K     40.8M  … 41.7M           0 ( 0%)        0%
  branch_misses       116M  ± 67.8K      116M  …  116M           0 ( 0%)        0%
Benchmark 2 (197 runs): new/zig build-obj -fno-emit-bin -femit-docs=docs ../lib/std/std.zig
  measurement          mean ± σ            min … max           outliers         delta
  wall_time          24.6ms ± 1.03ms    22.8ms … 28.3ms          4 ( 2%)        ⚡- 99.8% ±  0.3%
  peak_rss           87.3MB ± 60.6KB    87.2MB … 87.4MB          0 ( 0%)        ⚡- 91.9% ±  0.0%
  cpu_cycles         38.4M  ±  903K     37.4M  … 46.1M          13 ( 7%)        ⚡- 99.9% ±  0.2%
  instructions       39.7M  ± 12.4K     39.7M  … 39.8M           0 ( 0%)        ⚡-100.0% ±  0.0%
  cache_references   2.65M  ± 89.1K     2.54M  … 3.43M           3 ( 2%)        ⚡- 99.9% ±  0.2%
  cache_misses        197K  ± 5.71K      186K  …  209K           0 ( 0%)        ⚡- 99.5% ±  0.1%
  branch_misses       184K  ± 1.97K      178K  …  190K           6 ( 3%)        ⚡- 99.8% ±  0.0%
```

过去需要 13 秒以上，而现在只需要 25 毫秒。

### Autodoc 新特性

- 更加可靠的链接：由于拥有完整的源代码，故我们拥有所有元信息，并且可以编写更强大的代码来从它们出现的上下文中查找标识符。

- 交互式源列表：只要按下 **u**，你可以立刻查看当前声明或者定义的源代码（通过更改 location 哈希实现）！

- 更加清晰的列表

- 搜索支持注释

- 更加友好的错误集合展示（支持通过其他的声明进行跳转）

- 函数说明也会展示错误类型说明

- 正确的类型检测（旧实现可能会猜错）

- 浏览历史的正确记录（依赖于 `popstate` 事件 和历史记录 api）

::: info

更加全面的信息，可以查看 [commit diff](https://github.com/andrewrk/autodoc/commit/6d96a63430b39c8a08158410b25dd0ecafea28db)。

:::

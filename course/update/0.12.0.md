---
outline: deep
comments: false
---

# `0.12.0`

2024/4/20，`0.12.0` 终于发布了，历时 8 个月，有 268 位贡献者，一共进行了 3688 次提交！

> 过去的发行说明都异常的长，因为试图记录所有在开发周期中所有的变化，本次更新则进行了适当地删减，便于读者和维护者阅读！

::: info

注意： 存在一部分变动并未在本次的发行说明中提及，其中包括 API 的 `Break Change`。

:::

TODO: 增加四层支持的变化说明！

## 语言变动

`0.12.0` 进行一些语言方面的变动，以下是详细说明！

### 非必要不使用 `var`

引入了一个新的编译错误，当局部变量声明为 `var` 但使用 `const` 就足够时，编译器会发出该错误！

```zig
const expectEqual = @import("std").testing.expectEqual;
test "unnecessary use of var" {
    var x: u32 = 123;
    try expectEqual(123, x);
}
```

```sh
$ zig test unnecessary_var.zig
docgen_tmp/unnecessary_var.zig:3:9: error: local variable is never mutated
    var x: u32 = 123;
        ^
docgen_tmp/unnecessary_var.zig:3:9: note: consider using 'const'
```

解决该错误也很简单，使用 `const` 即可！

### 结果位置语义

对结果位置语义 _Result Location Semantics (RLS)_ 的多项增强。

::: info

结果位置语义是Zig语言中的一个特性，它影响函数如何返回结果和错误。

:::

结果类型（result types）可以通过取地址运算符（`&`）进行传递。这允许依赖结果类型的语法结构，如匿名初始化 `.{ ... }` 和像 `@intCast` 这样的转换内建函数，在存在取地址运算符的情况下正确地工作。这是一种新的特性，可以使代码在处理结果类型时更加灵活和准确。

```zig
const S = struct { x: u32 };
const int: u64 = 123;
const val: *const S = &.{ .x = @intCast(int) };
comptime {
    _ = val;
}
```

::: info

此外，在这个版本中，结果位置（**result locations**）不能通过@as和明确类型的聚合初始化T{ ... }进行传播。这个限制是为了简化语言设计。在之前的版本中，有几个关于结果指针（result pointers）错误转换的 bug，这个更改就是为了解决这些问题。

:::

### 解构语法（Aggregate Destructuring）

引入了新语法，允许对可索引的聚合结构（如元组、向量和数组）进行解构。在赋值操作的左侧编写一系列的左值或本地变量声明，将尝试解构右侧指定的值。这是一种新的赋值方式，可以更方便地从聚合结构中提取值：

```zig
var z: u32 = undefined;
const x, var y, z = [3]u32{ 1, 2, 3 };
y += 10;
// x 是 1，y 是 12，z 是 3

const x, const y = @Vector(2, u32){ 1, 2 };
// 编译期的值也会进行解构，x 是 1，y 是 2

var runtime: u32 = undefined;
runtime = 123;
const x, const y = .{ 42, runtime };
// 当然，编译期和运行时的值也会被正确解析
// x 是编译期可以知道的值 42
// y 是运行时可知的值 123

```

::: warning

**切片**（slices）不能直接被解构，如果想从切片中解构值，需要将它转换为数组，方法是使用编译时已知的边界进行切割，例如 `slice[0..3].*`。这样，就可以像处理数组一样处理切片，从而实现解构。

:::

### 命名空间类型等价性

在Zig中，结构体（`struct`）、枚举（`enum`）、联合体（`union`）和不透明类型（`opaque types`）是特殊的，它们不像元组和数组那样使用结构等价性，而是创建独特的类型。这些类型有命名空间，因此可能包含声明，它们可以统称为"命名空间类型"。

在 `0.11.0` 版本中，每次这样的类型声明被语义分析时，都会创建一个新的类型。泛型类型的等价性是通过对编译时函数调用的记忆化（memoization）来处理的；也就是说，`std.ArrayList(u8) == std.ArrayList(u8)` 成立，因为 `ArrayList` 函数只被调用一次，其结果被记忆化。

在0.12.0版本中，这一点发生了变化。现在，命名空间类型基于两个因素进行去重：它们的源位置和它们的捕获。

类型的"捕获"指的是它闭包覆盖的编译时已知类型和值的集合。换句话说，它是在类型内部引用但在类型外部声明的值的集合。例如，`std.ArrayList` 的编译时 `T: type` 参数被它返回的类型捕获。如果两个命名空间类型由同一段代码声明并且有相同的捕获，那么它们现在被认为是完全相同的类型。

请注意，编译器仍然会记忆化编译时调用：这一点没有改变。然而，这种记忆化对语言语义的影响已经不再有意义。

这种实现的更改不太可能带来改变，但需要注意以下情况：

```zig
fn MakeOpaque(comptime n: comptime_int) type {
    _ = n;
    return opaque {};
}
const A = MakeOpaque(0);
const B = MakeOpaque(1);
```

在 Zig `0.11.0` 版本中，这段代码会创建两个不同的类型，因为对 `MakeOpaque` 的调用是不同的，因此每次调用都会单独分析不透明声明。而在 `Zig 0.12.0` 版本中，这些类型是相同的（A == B），因为虽然函数被调用了两次，但声明并没有捕获任何值。

要修正这个问题也很简单，强制捕获 `n` 就可以了：

```zig
fn MakeOpaque(comptime n: comptime_int) type {
    return opaque {
        comptime {
            _ = n;
        }
    };
}
const A = MakeOpaque(0);
const B = MakeOpaque(1);
```

由于 `n` 被 `opaque` 强制引用，将会产生两个不同的类型！

### 编译期内存变化

对编译器的编译时内存（comptime memory）的内部表示，特别是编译时可变内存（即 `comptime var`）进行了全面改革。这次改革带来了一些面向用户的变化，以新的限制的形式出现，限制了你可以对 `comptime var` 做什么。

第一个也是最重要的新规则是，永远不允许指向 a comptime var 的指针成为运行时已知的。例如：

```zig
test "runtime-known comptime var pointer" {
    comptime var x: u32 = 123;
    // `var` 使得 `ptr` 运行时可知
    var ptr: *const u32 = undefined;
    ptr = &x;
    if (ptr.* != 123) return error.TestFailed;
}
```

```sh
$ zig test comptime_var_ptr_runtime.zig
docgen_tmp/comptime_var_ptr_runtime.zig:5:11: error: runtime value contains reference to comptime var
    ptr = &x;
          ^~
docgen_tmp/comptime_var_ptr_runtime.zig:5:11: note: comptime var pointers are not available at runtime
```

在早期版本的 Zig 中，此测试会通过。现在，编译器会报告编译错误，因为对 `ptr` 的赋值使得值 `&x`（这是一个指向 `comptime var` 的指针）变为运行时已知。

例如，通过将这样的指针传递给在运行时调用的函数，这些指针也可以变为运行时已知：

```zig
test "comptime var pointer as runtime argument" {
    comptime var x: u32 = 123;
    if (load(&x) != 123) return error.TestFailed;
}
fn load(ptr: *const u32) u32 {
    return ptr.*;
}
```

```sh
$ zig test comptime_var_ptr_runtime_arg.zig
docgen_tmp/comptime_var_ptr_runtime_arg.zig:3:14: error: runtime value contains reference to comptime var
    if (load(&x) != 123) return error.TestFailed;
             ^~
docgen_tmp/comptime_var_ptr_runtime_arg.zig:3:14: note: comptime var pointers are not available at runtime
```

现在，这个测试也会发出一个编译错误。`load` 的调用发生在运行时，它的 `ptr` 参数没有标记为 `comptime`，所以在 `load` 的主体内，`ptr` 是运行时已知的。这意味着调用 `load` 使得指针 `&x` 在运行时已知，因此产生了编译错误。

这个限制是为了修复一些反直觉的错误。当一个指向comptime var的指针变为运行时已知时，对它的修改变得无效，因为指向的数据变为常量，但类型系统没有反映这一点，导致在看似有效的代码中可能出现运行时段错误。此外，你在运行时从这样的指针读取的值将是它的"最终"编译时值，这是一种不直观的行为。因此，这些指针不能再是运行时已知的。

第二个新的限制是一个指向 `comptime var` 的指针永远不允许包含在全局声明的解析值中。例如：

```zig
const ptr: *const u32 = ptr: {
    var x: u32 = 123;
    break :ptr &x;
};
comptime {
    _ = ptr;
}
```

```sh
$ zig test comptime_var_ptr_global.zig
docgen_tmp/comptime_var_ptr_global.zig:1:30: error: global variable contains reference to comptime var
const ptr: *const u32 = ptr: {
                        ~~~~~^
referenced by:
    comptime_0: docgen_tmp/comptime_var_ptr_global.zig:6:9
    remaining reference traces hidden; use '-freference-trace' to see all reference traces
```

在这里，`ptr` 是一个全局声明，其值是一个指向 `comptime var` 的指针。这个声明在 `0.11.0` 中是允许的，但在 `0.12.0` 中会引发一个编译错误。在更复杂的情况下，同样的规则也适用，例如当指针包含在结构体字段中时：

```zig
const S = struct { ptr: *const u32 };
const val: S = blk: {
    var x: u32 = 123;
    break :blk .{ .ptr = &x };
};
comptime {
    _ = val;
}
```

```sh
$ zig test comptime_var_ptr_global_struct.zig
docgen_tmp/comptime_var_ptr_global_struct.zig:2:21: error: global variable contains reference to comptime var
const val: S = blk: {
               ~~~~~^
referenced by:
    comptime_0: docgen_tmp/comptime_var_ptr_global_struct.zig:7:9
    remaining reference traces hidden; use '-freference-trace' to see all reference traces
```

这段代码引发的编译错误与前一个例子相同。这个限制主要是为了帮助在Zig编译器中实现增量编译，这依赖于全局声明的分析是顺序无关的，以及声明之间的依赖关系可以被轻易地建模。

这种情况最常见的表现形式是在现有代码中出现编译错误，如果一个函数在编译时构造一个切片，然后在运行时使用。例如，考虑以下代码：

```zig
fn getName() []const u8 {
    comptime var buf: [9]u8 = undefined;
    // 在实践中，这里可能会有更复杂的逻辑来填充 buf
    @memcpy(&buf, "some name");
    return &buf;
}
test getName {
    try @import("std").testing.expectEqualStrings("some name", getName());
}
```

```sh
$ zig test construct_slice_comptime.zig
docgen_tmp/construct_slice_comptime.zig:5:12: error: runtime value contains reference to comptime var
    return &buf;
           ^~~~
docgen_tmp/construct_slice_comptime.zig:5:12: note: comptime var pointers are not available at runtime
referenced by:
    decltest.getName: docgen_tmp/construct_slice_comptime.zig:8:64
    remaining reference traces hidden; use '-freference-trace' to see all reference traces
```

调用getName返回一个切片，其ptr字段是一个指向comptime var的指针。这意味着这个值不能在运行时使用，也不能出现在全局声明的值中。这段代码可以通过在填充缓冲区后将计算的数据提升为const来修复：

```zig
fn getName() []const u8 {
    comptime var buf: [9]u8 = undefined;
    // In practice there would likely be more complex logic here to populate `buf`.
    @memcpy(&buf, "some name");
    const final_name = buf;
    return &final_name;
}
test getName {
    try @import("std").testing.expectEqualStrings("some name", getName());
}
```

像在Zig的早期版本中一样，编译时已知的consts具有无限的生命周期，这里讨论的限制不适用于它们。因此，这段代码会正常运行。

另一种可能的失败模式是在使用旧语义创建全局可变编译时状态的代码中。例如，以下片段试图创建一个全局的编译时计数器：

```zig
const counter: *u32 = counter: {
    var n: u32 = 0;
    break :counter &n;
};
comptime {
    counter.* += 1;
}
```

```sh
$ zig test global_comptime_counter.zig
docgen_tmp/global_comptime_counter.zig:1:32: error: global variable contains reference to comptime var
const counter: *u32 = counter: {
                      ~~~~~~~~~^
referenced by:
    comptime_0: docgen_tmp/global_comptime_counter.zig:6:5
    remaining reference traces hidden; use '-freference-trace' to see all reference traces
```

这段代码在 Zig `0.12.0` 中会发出一个编译错误。Zig不支持也不会支持这种用例：任何可变的编译时状态必须在本地表示。

### `@fieldParentPtr`

删除了第一个参数，以支持使用结果类型。

迁移指南：

```zig
const parent_ptr = @fieldParentPtr(Parent, "field_name", field_ptr);
```

变为：

```zig
const parent_ptr: *Parent = @fieldParentPtr("field_name", field_ptr);
```

或者

```zig
const parent_ptr: *Parent = @alignCast(@fieldParentPtr("field_name", field_ptr));
```

这取决于编译器能够证明的父指针对齐。第二种形式更具有可移植性，因为对于某些目标可能需要 `@alignCast` ，而对于其他目标可能不需要。

### 禁止在函数类型上进行对齐

`0.11.0` 允许函数类型指定对齐。在 `0.12.0` 中，这是不允许的，因为它是函数声明和指针的属性，而不是函数类型的属性。

```zig
comptime {
    _ = fn () align(4) void;
}
```

会报告以下错误：

```sh
$ zig test func_type_align.zig
docgen_tmp/func_type_align.zig:2:21: error: function type cannot have an alignment
    _ = fn () align(4) void;
```

### `@errorCast`

过去发布的版本包含了一个 `@errSetCast` 内置函数，它执行从一个错误集到另一个可能更小的错误集的安全检查转换。在 `0.12.0` 中，这个内置函数被 `@errorCast` 替换。它将继续发挥原本的作用，但此外，这个新的内置函数可以转换错误联合类型的错误集：

```zig
const testing = @import("std").testing;

test "@errorCast error set" {
    const err: error{Foo, Bar} = error.Foo;
    const casted: error{Foo} = @errorCast(err);
    try testing.expectEqual(error.Foo, casted);
}

test "@errorCast error union" {
    const err: error{Foo, Bar}!u32 = error.Foo;
    const casted: error{Foo}!u32 = @errorCast(err);
    try testing.expectError(error.Foo, casted);
}

test "@errorCast error union payload" {
    const err: error{Foo, Bar}!u32 = 123;
    const casted: error{Foo}!u32 = @errorCast(err);
    try testing.expectEqual(123, casted);
}
```

### `@abs`

过去的版本包含了 `@fabs` 内置函数。这已被新的 `@abs` 内置函数替换，它能够对整数以及浮点数进行操作。

```zig
const expectEqual = @import("std").testing.expectEqual;

test "@abs on float" {
    const x: f32 = -123.5;
    const y = @abs(x);
    try expectEqual(123.5, y);
}

test "@abs on int" {
    const x: i32 = -12345;
    const y = @abs(x);
    try expectEqual(12345, y);
}
```

## 标准库

在 Windows 上，程序的命令行参数是一个单一的 WTF-16 编码字符串，由程序来将其分割成字符串数组。在 C/C++ 中，C 运行时的入口点负责分割命令行并将 argc/argv 传递给 main 函数。

以前，`ArgIteratorWindows` 匹配 `CommandLineToArgvW` 的行为，但事实证明，CommandLineToArgvW 的行为并不匹配 2008 年后的 C 运行时。在 2008 年，C 运行时的 argv 分割[改变了它如何处理引用参数中的连续双引号](https://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULESDOC)（现在被认为是转义引号，例如 `"foo""bar"` 在2008年后会被解析成 `foo"bar`），并且 `argv[0]` 的规则也被改变了。

这个版本使 ArgIteratorWindows 匹配 2008 年后的 C 运行时的行为。这里的动机大致与 Rust 做出同样的改变时相同，即（改述）：

- Zig 和现代 C/C++ 程序之间的一致行为

- 允许用户以更直接的方式转义双引号

此外，对 [BatBadBut](https://flatt.tech/research/posts/batbadbut-you-cant-securely-execute-commands-on-windows/) 的建议的缓解措施依赖于 2008 年后的 argv 分割行为，以便对给 cmd.exe 的参数进行往返处理。

[BadBatBut 的缓解措施](https://github.com/ziglang/zig/pull/19698)没有在0.12.0版本的发布截止日期之前完成。

### 回归操作系统 API 层

Zig 的历史版本允许应用程序覆盖标准库的 POSIX API 层。这个版本故意移除了这个能力，没有提供迁移路径。

这从一开始就是一个错误。这不是在这个抽象层做这个的正确方式。

对此的另一种计划是使所有 I/O 操作都需要一个 IO 接口参数，类似于今天的分配需要一个 Allocator 接口参数。

这样的计划尚未实施，所以需要这个功能的应用程序必须维护一个标准库的分支，直到那时。

### `std.os` 命名为 `std.posix`

迁移方式：

```zig
std.os.abort();
```

到

```zig
std.posix.abort();
```

通常，人们应该更倾向于使用更高级别的跨平台抽象，而不是深入到 POSIX API 层。例如， `std.process.exit` 比 `std.posix.exit` 更具有可移植性。你通常应该期望在操作系统实现相应的 POSIX 功能时，`std.posix` 内的 API 在给定的操作系统上是可用的。

### Ryu 浮点数格式化

Zig 0.12.0 用基于 Ryu 的算法替换了先前的 errol 浮点数格式化算法，Ryu 是一种用于将 IEEE-754 浮点数转换为十进制字符串的现代算法。

这带来的改进包括：

- 能够格式化 f80 和 f128 类型
- 更准确的 f16 和 f32 格式化
- 对每种浮点类型的完全往返支持
- 通用后端，可以用来打印任何一般位数的浮点数（小于或等于 128 位）

差异：

- 指数不再用前导 0 填充到 2 位，如果是正数，不再打印符号:

```sh
errol: 2.0e+00
ryu:   2e0
```

- 在除 `f64` 之外的所有情况下，全精度输出更准确，因为我们不再在内部进行 `f64` 的转换：

```sh
# Ryu
3.1234567891011121314151617181920212E0 :f128
3.1234567891011121314E0 :f80
3.1234567891011121314E0 :c_longdouble
3.123456789101112E0 :f64
3.1234567E0 :f32
3.123E0 :f16

## Errol
3.123456789101112e+00 :f128
3.123456789101112e+00 :f80
3.123456789101112e+00 :c_longdouble
3.123456789101112e+00 :f64
3.12345671e+00 :f32
3.123046875e+00 :f16
```

此外，在这些情况下，固定精度情况下的舍入行为也可能不同，因为最短表示通常会有所不同：

```sh
# bits:         141333
# precision:    3
# std_shortest: 1.98049715e-40
# ryu_shortest: 1.9805e-40
# type:         f32
|
| std_dec: 0.000
| ryu_dec: 0.000
|
| std_exp: 1.980e-40
| ryu_exp: 1.981e-40
```

性能：约提高2.3倍

代码大小：大约增加5KB（2倍）

以上源代码：[Github](https://github.com/ziglang/zig/pull/19229)

### 重构HTTP

首先，一些非常直接的更改：

- 不发出 Server HTTP 头。如果用户希望添加，让他们自己添加。这不是严格必要的，可以说是一个有害的默认设置。
- 修正 `finish` 的错误集，不再包含 NotWriteable 和 MessageTooLong
  在Server中防止零长度的块
- 在 FetchOptions 中添加缺失的重定向行为选项，并将其改为枚举，而不是2个字段
- `error.CompressionNotSupported` 被重命名为 `error.CompressionUnsupported`，与同一集合中所有其他错误的命名约定相匹配。
- 删除了与字段和类型名称重复的文档注释。
- 暂时禁用服务器中的zstd解压缩；参见[#18937](https://github.com/ziglang/zig/issues/18937)。
- Automatically handle expect: 100-continue requests

接下来，**移除了堆分配头部缓冲区的能力**。HTTP 头部的缓冲区现在总是通过静态缓冲区提供。因此，`OutOfMemory` 不再是 `read()` 错误集的成员，`Client` 和 `Server` 的 API 和实现得到了简化。`error.HttpHeadersExceededSizeLimit` 被重命名为 `error.HttpHeadersOversize`。

大的变动：

#### 移除 `std.http.Headers`

相反，一些头部通过在解析 HTTP 请求/响应时填充的显式字段名提供，一些通过支持传递额外、任意头部的新字段提供。这在许多地方简化了逻辑，也消除了许多地方的失败可能性。现在进行的反初始化代码更少了。此外，它使得不再需要克隆头部数据结构来处理重定向。

http_proxy 和 https_proxy 字段现在是指针，因为它们通常未被填充。

将 `loadDefaultProxies` 改为 `initDefaultProxies` ，以表明它实际上并未从磁盘或网络加载任何东西。现在的函数是有泄漏的；API用户必须传递一个已经实例化的竞技场分配器。消除了反初始化代理的需要。

以前，代理存储了任意的头部集合。现在它们只存储授权值。

删除了 https_proxy 和 http_proxy 之间的重复代码。最后，环境变量的解析失败会导致错误被发出，而不是默默地忽略代理。

#### 完全重构 Server

主要移除了名字起得不好的 `wait`、`send`、`finish` 函数，它们都在同一个"`Response`"对象上操作，实际上这个对象被用作请求。

现在，看起来像：

- `std.net.Server.accept()` 会给你一个 `std.net.Server.Connection`
- 使用 `connection` 初始化 `std.http.Server.init()`
- `Server.receiveHead()` 会给你一个请求
- `Request.reader()` 给出一个 body 的 reader
- `Request.respond()` 是一次性的，或者 `Request.respondStreaming()` 创建一个`Response`
- `Response.writer()` 给出一个 body 的writer
- `Response.end()` 完成响应；`Response.endChunked()` 允许传递响应尾部。

换句话说，类型系统现在引导API用户走正确的路径。

`receiveHead` 允许将额外的字节读入读缓冲区，然后将这些字节用于主体或在连接复用时用于下一个请求。

`respond()`，一次性函数，将在一次系统调用中发送整个响应。

流式响应体不再浪费地用块头和尾部包装每次写入调用；相反，它只在刷新时发送HTTP块包装器。这意味着用户仍然可以控制何时发生，但它也不会添加不必要的块。

从经验上看，使用代码显著地减少了噪音，它在更正确地处理错误的同时减少了错误处理，更明显地显示了正在发生的事情，并且是系统调用最优的。

```zig
var read_buffer: [8000]u8 = undefined;
    accept: while (true) {
        const connection = try http_server.accept();
        defer connection.stream.close();

        var server = std.http.Server.init(connection, &read_buffer);
        while (server.state == .ready) {
            var request = server.receiveHead() catch |err| {
                std.debug.print("error: {s}\n", .{@errorName(err)});
                continue :accept;
            };
            try static_http_file_server.serve(&request);
        }
    }
```

```zig
pub fn serve(context: *Context, request: *std.http.Server.Request) ServeError!void {
    // ...
    return request.respond(content, .{
        .status = status,
        .extra_headers = &.{
            .{ .name = "content-type", .value = @tagName(file.mime_type) },
        },
    });
```

还有：

- 将 `std.http.HeadParser` 从 `protocol.zig` 中解耦
- 删除 `std.Server.Connection` ；改为使用 `std.net.Server.Connection`。
  - API 使用者在初始化 http.Server 时提供读缓冲区，它用于 HTTP 头以及读取主体的缓冲区。
- 替换并记录 `State` 枚举。不再有 "start" 和 "first"。

`std.http.Client` 尚未像 `std.http.Server` 那样进行类似的重构。

## Autodoc 重构

目前我们已经可以使用全新的 `Autodoc`，新的实现带来了更棒的文档阅读体验！

### 旧的实现

文件结构为：

```sh
   5987 src/Autodoc.zig
   435 src/autodoc/render_source.zig
 10270 lib/docs/commonmark.js
  1245 lib/docs/index.html
  5242 lib/docs/main.js
  2146 lib/docs/ziglexer.js
 25325 total
```

编译产物结构（演示使用的标准库文档）为：

```sh
272K commonmark.js
3.8M data-astNodes.js
360K data-calls.js
767K data-comptimeExprs.js
2.2M data-decls.js
896K data-exprs.js
 13K data-files.js
  45 data-guideSections.js
 129 data-modules.js
  15 data-rootMod.js
 294 data-typeKinds.js
3.2M data-types.js
 38K index.html
158K main.js
 36M src/ (470 .zig.html files)
 78K ziglexer.js
```

总输出大小为 **47M**，经过gzip处理后为 **5.7M**！

- `src/Autodoc.zig` 用于处理 ZIR 代码（zig 编译时产生的中间代码），输出 json 以便 js 使用，这就导致很多代码无法通过某些数据（这些数据很可能是无效的），重建 AST 语法树

- `lib/docs/commonmark.js` 是一个第三方的 markdown 实现，但它的特性有点太多了，例如，我们并不希望在文档注释中使用HTML标签，因为这样会让源代码的注释无比丑陋，应当只渲染源代码和 markdown。

- lib/docs/ziglexer.js` 是 js 中针对 zig 的语义标记实现。事实上，zig 已经在标准库中公开了由 zig 实现的语义标记。有趣的是，**andrewrk** 看到这个东西被添加进来的时候应该两眼一黑，具体可以见 [Issue 16306](https://github.com/ziglang/zig/pull/16306) [Issue 16490](https://github.com/ziglang/zig/issues/16490) 。

- `src/autodoc/render_source.zig` 是一种将 `.zig` 文件转换为带有语法高亮但不是交互式的 `.zig.html` 文件。

### 新的实现

文件结构为：

```sh
   942 lib/docs/main.js
   403 lib/docs/index.html
   933 lib/docs/wasm/markdown.zig
   226 lib/docs/wasm/Decl.zig
  1500 lib/docs/wasm/markdown/Parser.zig
   254 lib/docs/wasm/markdown/renderer.zig
   192 lib/docs/wasm/markdown/Document.zig
   941 lib/docs/wasm/main.zig
  1038 lib/docs/wasm/Walk.zig
  6630 total
```

编译产物结构（演示使用的标准库文档）为：

```sh
 12K index.html
 32K main.js
192K main.wasm
 12M sources.tar
```

总输出大小为: **12M**，经过gzip处理后为 **2.3M**！

可以看到，新的实现的代码和产物都很简洁，产物刚刚好只有 4 个文件，并且文件大小直接缩减到了 **1/4** 。

新的实现不仅仅是表面看上去更简单，实际上它较之旧实现更加的强大，因为新的实现并不会处理 ZIR，而是直接读取解析源代码文件（`sources.tar` 就是打包的源代码），这意味着它拥有完整的源代码信息，不需要进行一些乱七八糟的推断。

此方案是使用 zig 编写的 WebAssembly 模块，这允许其重用编译器中的组件，例如分词器，解析器和其他用于对 zig 代码进行操作的一些程序。

通过 HTTP 请求`sources.tar` 文件并解压后，会将其直接送入 Wasm 模块的内存中，针对 tar 文件使用 `std.tar` 进行解析，源代码就地进行解析，并额外进行一些计算添加 hash 表。

针对目前的实现，优化空间可以使用多线程来加速解析，但目前来看单线程已经足够快了，似乎没有必要。

### 携带标准库文档

在 zig 的 `0.11.0` 中，zig 发行时会带有一个 `docs/std/` 目录，其中包含着旧autodoc 实现构建产物（足足 47M 大小）。

在本次重写中，直接删除这些构建产物，作为代替，提供了 `zig std` 命令，这允许使用自带的 autodoc 生成器来打开一个浏览器窗口查看文档说明，首次使用此命令时，会先执行一次针对 `lib/compiler/std-docs.zig` 的编译操作。

HTTP 服务器会动态创建请求的文件，包括 main.wasm 重建（如果任何源文件发生更改）和构造 sources.tar ，这意味着在查看文档时，对文档文件或 autodoc 系统本身的任何源更改都会立即反映出来。在 URL 前面加上 /debug URL 会使用 WebAssembly 模块的调试版本。

这意味着贡献者可以通过在浏览器窗口中按刷新来测试对 Zig 标准库文档以及 autodocs 功能的更改，只需要 Zig 的二进制发行版。

总之，这使的zig的安装大小从 317M 减少到了 268M （-15%）。

编译器的 ReleaseSmall 版本从 10M 缩小到 9.8M （-1%）。

### 构建文档时间

Autodocs 生成现在作为编译器 pipeline 的一部分完成，而不是在最后添加。它也不再依赖于 pipeline 的其他部分。

以下是构建标准库文档所需要的时间：

```sh
Benchmark 1 (3 runs): old/zig test /home/andy/dev/zig/lib/std/std.zig -fno-emit-bin -femit-docs=docs
  measurement          mean ± σ            min … max           outliers         delta
  wall_time          13.3s  ±  405ms    12.8s  … 13.6s           0 ( 0%)        0%
  peak_rss           1.08GB ±  463KB    1.08GB … 1.08GB          0 ( 0%)        0%
  cpu_cycles         54.8G  ±  878M     54.3G  … 55.8G           0 ( 0%)        0%
  instructions        106G  ±  313K      106G  …  106G           0 ( 0%)        0%
  cache_references   2.11G  ± 35.4M     2.07G  … 2.14G           0 ( 0%)        0%
  cache_misses       41.3M  ±  455K     40.8M  … 41.7M           0 ( 0%)        0%
  branch_misses       116M  ± 67.8K      116M  …  116M           0 ( 0%)        0%
Benchmark 2 (197 runs): new/zig build-obj -fno-emit-bin -femit-docs=docs ../lib/std/std.zig
  measurement          mean ± σ            min … max           outliers         delta
  wall_time          24.6ms ± 1.03ms    22.8ms … 28.3ms          4 ( 2%)        ⚡- 99.8% ±  0.3%
  peak_rss           87.3MB ± 60.6KB    87.2MB … 87.4MB          0 ( 0%)        ⚡- 91.9% ±  0.0%
  cpu_cycles         38.4M  ±  903K     37.4M  … 46.1M          13 ( 7%)        ⚡- 99.9% ±  0.2%
  instructions       39.7M  ± 12.4K     39.7M  … 39.8M           0 ( 0%)        ⚡-100.0% ±  0.0%
  cache_references   2.65M  ± 89.1K     2.54M  … 3.43M           3 ( 2%)        ⚡- 99.9% ±  0.2%
  cache_misses        197K  ± 5.71K      186K  …  209K           0 ( 0%)        ⚡- 99.5% ±  0.1%
  branch_misses       184K  ± 1.97K      178K  …  190K           6 ( 3%)        ⚡- 99.8% ±  0.0%
```

过去需要 13 秒以上，而现在只需要 25 毫秒。

### Autodoc 新特性

- 更加可靠的链接：由于拥有完整的源代码，故我们拥有所有元信息，并且可以编写更强大的代码来从它们出现的上下文中查找标识符。

- 交互式源列表：只要按下 **u**，你可以立刻查看当前声明或者定义的源代码（通过更改 location 哈希实现）！

- 更加清晰的列表

- 搜索支持注释

- 更加友好的错误集合展示（支持通过其他的声明进行跳转）

- 函数说明也会展示错误类型说明

- 正确的类型检测（旧实现可能会猜错）

- 浏览历史的正确记录（依赖于 `popstate` 事件 和历史记录 api）

::: info

更加全面的信息，可以查看 [commit diff](https://github.com/andrewrk/autodoc/commit/6d96a63430b39c8a08158410b25dd0ecafea28db)。

:::
